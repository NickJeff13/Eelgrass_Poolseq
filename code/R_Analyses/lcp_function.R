## function to calculate the least-cost paths between locations 

lcp_function <- function (x,radius = 200,basemap,bound_box,matrix_out = TRUE,resolution=10,lines=FALSE,recalculate=FALSE,transition_name,rad,dirs=16){
  
  #get the required libraries
  require(sf)
  require(tidyr)
  require(dplyr)
  require(raster)
  require(ggplot2)
  require(gdistance)
  require(nngeo)
  require(fasterize)
  require(reshape2)
  
  # x is the sf dataframe with the coordinates for the sites of interest. This dataframe must have the column 'site.id' to specify the name of each site. 
  # radius is the radius around the sites that will be used to set up a dynamic 
  # basemap is a sf polygon that shows the coast. This will be generated by the code unless otherwise specified. 
  # bound_box is a polygon that is used to trim the basemap
  # matrix out is a logical determining whether a distance matrix will be returned (default - TRUE) or a data.frame (FALSE)
  # resolution is the resolution in km for the transition object. Note that for very large scales this should be larger (default 10 km). 
  # lines logical specifying whether you want to extract the full paths as sf linestrings (default is FALSE)
  # recalculate is a logical as to whether the transition object (slowest part of the process should force recalculated)
  # transition_name - this is a name used to create the transition object and check to see if it should be recalculated. Note that the resolution is appended at the end of this name (e.g., atlantic_arctic_25km)
  # rad is the 'radius' searching funciton provided to coord_bump 
  # dirs is the 'directions' for the transition object. 
  
  #latitude and longitude projection 
  latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
  
  #Data check
  if(sum(names(x)%in%"site_id")!=1){stop("a column with the name 'site.id' must be included to capture the site name")}
  
  #load basemap for the least-cost path analysis
  if(is.null(basemap)){
    
    require(rnaturalearth)
    require(rnaturalearthhires)
    
    basemap <- rbind(ne_states(country = "Canada",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="Canada"),
                     ne_states(country = "United States of America",returnclass = "sf")%>%
                       dplyr::select(name_en,geometry)%>%
                       st_as_sf()%>%
                       st_union()%>%
                       st_transform(latlong)%>%
                       st_as_sf()%>%
                       mutate(country="USA"))%>%st_union()%>%st_as_sf()
    
  }
  
  #make sure data is set to the projection used in the analysis
  x = x%>%st_transform(latlong)
  
  #check to see if the 
  trans_check <- file.exists(paste0("Data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
  
  #create dynamic projection to set the boundaries of the least-cost path analysis
  pts_center <- x%>%
                summarise()%>%
                st_centroid()%>%
                st_transform(latlong)%>%
                suppressWarnings()%>%
                suppressMessages()
              
  aeqd <- sprintf("+proj=aeqd +lat_0=%s +lon_0=%s +x_0=0 +y_0=0",
                       st_coordinates(pts_center)[2], st_coordinates(pts_center)[1])
  
  #set cropping buffer to create a transition object
  
  max_dist <- (max(st_distance(x)%>%as.numeric()/1000)+25)%>%round() #maximum distance between stations + 25km radius
  
  buffer_pts <- st_buffer(pts_center%>%st_transform(aeqd),dist=units::set_units(max_dist,"km"))%>%st_bbox()%>%st_as_sfc()%>%st_sf()
  
  #create raster at 5 km scale that can be used to develop the transition object
  r=suppressWarnings(raster(raster::extent(buffer_pts),res=resolution*1000,crs=aeqd)%>%projectRaster(.,crs=latlong))
  
  coast <- basemap%>%st_intersection(bound_box)
   
  ind <- r%>%
          fasterize(coast,.)%>%
          values(.)%>%
          as.data.frame()%>%
          rename(val=1)%>%
          mutate(val=is.na(val))%>%
          pull(val)
  
  #set raster value for the transition matrix
  r[] <- 0 #land - no conductance
  r[ind] <- 1 #water (note set to 1, if you set to 10 you change the costDistance calculation)
  
  #raster used to ensure the sample sites are in water
  r2 <- r
  r2[] <- 10
  r2[ind] <- -10
  
  #adjust coordinates so they are in the water. 
  
  message("Adjusting sites into water")
  
  samplesite_adjusted <- x%>%
                          mutate(site_id=factor(site_id,levels=c(x$site_id)))%>% #this will enforce the order of sample sites onto the grouping
                          as.data.frame()%>%
                          group_by(site_id)%>%
                          do(coord_bump(.,r2,radius=rad))%>%
                          ungroup()%>%
                          mutate(site_id=as.character(site_id))%>%
                          left_join(.,x)%>%
                          st_as_sf(coords=c("lon_a","lat_a"),crs=latlong,remove=FALSE)
  
  #calculate the offset between the recorded location and the location that the site was bumped to. This can be added to the distance for that site to any other site
  samplesite_adjusted$offset=9999 #placeholder for the distances 
  
  for(i in samplesite_adjusted$site_id){
    
    site <- samplesite_adjusted%>%filter(site_id == i)
    
    samplesite_adjusted[samplesite_adjusted$site_id == i,"offset"] <- st_distance(site,st_as_sf(data.frame(site),coords=c("long","lat"),crs=st_crs(site)))%>%
      as.numeric()/1000#distance in km
    
    rm(site)
    
  }
  
  ## create row index that can be used for matching
  samplesite_adjusted$ind <- 1:nrow(samplesite_adjusted)
  
  #create the transition layer for distance calculations if required
  if(!trans_check | recalculate){
  
    message("Creating transition layer. This can take some time. ")
    
    trans <- transition(r,transitionFunction = min,directions=dirs)%>%
          geoCorrection(.,type="c",multpl = FALSE)
        
        #save the transition object
        if(!dir.exists("Data/transition objects/")){dir.create("Data/transition objects/")}
        
        save(trans,file=paste0("Data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))
  
  } else {load(paste0("Data/transition objects/",transition_name,"_",dirs,"_",resolution,"km.RData"))} #end the contextual if for the transition object. 
  
  ## Least-cost path analysis
  lcp_df <- suppressWarnings(costDistance(trans,as_Spatial(samplesite_adjusted))/1000)
  
  
  ## do a check for land-locked coords
  
  
  ## Least-cost path lines
  if(lines){
    
    message("Extracting linestrings")
  
      nb.loc <- nrow(samplesite_adjusted)
      path <- list()
      comb <- combn(1:nb.loc, 2)
      
      pairwise_lines <- NULL
      pb <- txtProgressBar(min = 0, max = ncol(comb), style = 3)
      for (i in 1:ncol(comb)) {
        
        origin <- samplesite_adjusted[comb[1, i],]%>%as_Spatial()
        goal <- samplesite_adjusted[comb[2, i],]%>%as_Spatial()
        temp <- gdistance::shortestPath(trans, origin, goal, 
                                        output = "SpatialLines")
       
        #convert to sf 
        #if there is more than one point then create a linestring, else create a point
        
        #linestring_logic <- length(temp@lines[[1]]@Lines[[1]]@coords)>1
        
        #if(linestring_logic){
        
        line_coords <- data.frame(temp@lines[[1]]@Lines[[1]]@coords)
        
        temp_sf <- st_as_sf(line_coords,coords=c("x","y"),crs=latlong)%>%
                    summarise(do_union = FALSE) %>%
                   st_cast("LINESTRING") %>%
                   mutate(origin = samplesite_adjusted[comb[1, i],]%>%pull(code),
                          dest = samplesite_adjusted[comb[2, i],]%>%pull(code),
                          id = paste(origin,dest,sep="-"),
                          len = nrow(line_coords))%>%
                   dplyr::select(origin,dest,id,len,geometry)
        #}
        
        #combine with i results
        pairwise_lines <- rbind(pairwise_lines,temp_sf)
    
        setTxtProgressBar(pb, i)
    
    } #end for (i in 1:ncol(comb))
  
  } #end if(lines)

  #create the outputs ----------
  
  #return a data.frame (site vs site) --- optional if matrix_out = TRUE
  if(!matrix_out){
    output <- melt(as.matrix(lcp_df), varnames = c("row", "col"))%>%
      mutate(start = samplesite_adjusted%>%data.frame()%>%.[row,"site_id"],
             end = samplesite_adjusted%>%data.frame()%>%.[col,'site_id'])%>%
      rename(dist=value)%>%
      dplyr::select(start,end,dist)
    
    #adjust for the bumps to water
    for(i in samplesite_adjusted$site_id){
      output[output$start == i & output$dist!=0 | output$end == i & output$dist!=0,"dist"] <- output[output$start == i & output$dist!=0 | 
                                                                                                       output$end == i & output$dist!=0,"dist"] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset)
      
      
    }
    
  }
  
  #return a distance matrix (sites by sites full matrix) -- DEFAULT
  if(matrix_out){
    
    output <- as.matrix(lcp_df)
    
    #match up the column names in the distance matrix
    rownames(output) <- samplesite_adjusted%>%data.frame()%>%pull(site_id) 
    colnames(output) <- samplesite_adjusted%>%data.frame()%>%pull(site_id) 
    
    #adjust for the bumps to water
    for(i in samplesite_adjusted$site_id){
      output[rownames(output)==i,output[rownames(output)==i,]>0] <- output[rownames(output)==i,output[rownames(output)==i,]>0] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset) #add offset to rows
      output[output[colnames(output)==i,]>0,colnames(output)==i] <- output[output[colnames(output)==i,]>0,colnames(output)==i] + samplesite_adjusted%>%filter(site_id == i)%>%pull(offset) #add offset to columns
    }
    
  }
  
  if(lines){
    
    temp <- output
    
    output <- list()
    output[[1]] <- temp
    output[[2]] <- pairwise_lines
    
    
  }
 
  #end function and return output
  return(output)
  
}